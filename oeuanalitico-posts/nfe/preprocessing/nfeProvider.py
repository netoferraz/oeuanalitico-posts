from faker.providers import BaseProvider
from faker import Factory
import string
import random
import re
import datetime


class Invoice(BaseProvider):
    """
    Provider for Eletronic Invoicing Number for Consumer (NFC-e)
    https://www.edicomgroup.com/en_US/news/5891-electronic-invoicing-in-brazil-nf-e-nfs-e-and-ct-e.html
    https://www.ibm.com/support/knowledgecenter/en/SSRJDU/einvoicing/SCN_eINV_Brazil_Definitions.htm

    A example of NFC-e:
    unmasked: 51080701212344000127550010000000981364112281
    masked: 51-0807-01.212.344/0001-27-55-001-000.000.098-136.411.228-1

    A NFC-e has an identifier with 44 digits which is compound by:
        02 digit code - federation unit code of the emitter of NFC-e
        04 digit code - Month and Year of emission of the invoice (YYMM format)
        14 digit code - CNPJ of the company who emited the NFC-e
        02 digit code - model of the NFC-e
        03 digit code - series of the NFC-e
        09 digit code - number of the NFC-e
        09 digit code - code of the NFC-e generated by the government system
        01 digit code - verification code

    This provider has two mainly methods:
        nfce which return a invoice identifier with mask
        nfce_code which return a invoice identifier without mask
    """
    __provider__ = 'invoice'
    __lang__ = "pt_BR"

    fake = Factory.create("pt_BR")
    # federation unit codes
    uf_cod_map = {
        'RO': 11,
        'AC': 12,
        'AM': 13,
        'RR': 14,
        'PA': 15,
        'AP': 16,
        'TO': 17,
        'MA': 21,
        'PI': 22,
        'CE': 23,
        'RN': 24,
        'PB': 25,
        'PE': 26,
        'AL': 27,
        'SE': 28,
        'BA': 29,
        'MG': 31,
        'ES': 32,
        'RJ': 33,
        'SP': 35,
        'PR': 41,
        'SC': 42,
        'RS': 43,
        'MS': 50,
        'MT': 51,
        'GO': 52,
        'DF': 53
    }

    def parse_date(self, date: datetime.datetime):
        """
        Parser to return a 04 digits code to compound an NFC-e code.
        """
        year_date = str(date.year)[-2:]
        month_date = str(date.month)
        if len(month_date) == 1:
            month_date = "0" + month_date
        code_date = f"{year_date}{month_date}"
        return code_date

    def validate_dtype(self, variable, type, error_msg):
        """
        Validation for data type
        """
        if not isinstance(variable, type):
            raise TypeError(f"{error_msg}")

    def nfce(self, **kwargs) -> str:
        """
        Return a 59 character identifier for NFC-e with mask

        Keyword Args:
            start_dt (datetime.datetime): if no invoice_no has been entered, a start datetime is needed to
            compute a random 04 digits code which has format YYMM. In case of missing value, an random date of the current year will be used.
            end_dt (datetime.datetime): if no invoice_no has been entered, an end datetime is needed to
            compute a random 04 digits code which has format YYMM. In case of missing value, an random datevof the current year will be used.
            uf_code(str): a common two letter abbreviation for brazilian states (http://www.brazil-help.com/brazilian_states.htm)
        """
        start_dt = kwargs.get('start_dt')
        end_dt = kwargs.get('end_dt')
        if start_dt and end_dt:
            [self.validate_dtype(variable, datetime.datetime, "The date must be a datetime.datetime object.") for variable in [start_dt, end_dt]]
            picked_date = self.fake.date_between_dates(date_start=start_dt, date_end=end_dt)
            dt_code = self.parse_date(picked_date)  # 2 digits code (YYMM)
        else:
            picked_date = self.fake.date_time_this_year()
            dt_code = self.parse_date(picked_date)  # 2 digits code (YYMM)
        # federation unit code
        uf_choice = kwargs.get('uf_code')
        if uf_choice:
            try:
                get_uf_cod = self.uf_cod_map[uf_choice]
            except KeyError:
                raise KeyError("Invalid abbreviation for Brazilian State.")
        else:
            get_uf_cod = random.choice([cod for cod in self.uf_cod_map.values()])
        # CNPJ
        cnpj = str(self.fake.cnpj()).replace(".", "").replace("/", "").replace("-", "")
        nfce_cod = f"{get_uf_cod}{dt_code}{cnpj}"
        last_digits = "".join([random.choice(string.digits) for n in range(24)])
        cod_digits = nfce_cod + last_digits
        nfce_cod = f"{cod_digits[:2]}-{cod_digits[2:6]}-{cod_digits[6:8]}.{cod_digits[8:11]}.{cod_digits[11:14]}/{cod_digits[14:18]}-{cod_digits[18:20]}"\
            f"-{cod_digits[20:22]}-{cod_digits[22:25]}-{cod_digits[25:28]}.{cod_digits[28:31]}.{cod_digits[31:34]}-{cod_digits[34:37]}.{cod_digits[37:40]}."\
            f"{cod_digits[40:43]}-{cod_digits[43]}"
        return nfce_cod

    def nfce_code(self, **kwargs) -> str:
        """
        Return a 44 character code for NFC-e without mask
        Keyword Args:
            invoice_no (str): invoice number with 44 digits or its masked version with 59 character length
            start_dt (datetime.datetime): if no invoice_no has been entered, a start datetime is needed to
            compute a random 04 digits code which has format YYMM. In case of missing value, an random date of the current year will be used.
            end_dt (datetime.datetime): if no invoice_no has been entered, an end datetime is needed to
            compute a random 04 digits code which has format YYMM. In case of missing value, an random datevof the current year will be used.
            uf_code(str): a common two letter abbreviation for brazilian states (http://www.brazil-help.com/brazilian_states.htm)
        """
        code = self.nfce(**kwargs)
        code = code.replace("-", "").replace(".", "").replace("/", "")
        return code
