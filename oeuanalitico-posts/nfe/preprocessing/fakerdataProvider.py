from faker.providers import BaseProvider
from faker import Factory
import string
import random
import re
import datetime

class InvoiceNumber(BaseProvider):
    """
    Provider for Eletronic Invoicing Number for Consumer (NFC-e)
    https://www.edicomgroup.com/en_US/news/5891-electronic-invoicing-in-brazil-nf-e-nfs-e-and-ct-e.html
    https://www.ibm.com/support/knowledgecenter/en/SSRJDU/einvoicing/SCN_eINV_Brazil_Definitions.htm

    A example of NFC-e:
    unmasked: 51080701212344000127550010000000981364112281
    masked: 51-0807-01.212.344/0001-27-55-001-000.000.098-136.411.228-1

    A NFC-e has an identifier with 44 digits which is compound by:
        02 digit code - federation unit code of the emitter of NFC-e
        04 digit code - Month and Year of emission of the invoice (YYMM format)
        14 digit code - CNPJ of the company who emited the NFC-e
        02 digit code - model of the NFC-e
        03 digit code - series of the NFC-e
        09 digit code - number of the NFC-e
        09 digit code - code of the NFC-e generated by the government system
        01 digit code - verification code
    """
    __provider__ = 'invoice'
    __lang__ = "pt_BR"

    fake = Factory.create("pt_BR")
    # federation unit codes
    uf_cod = {
        'RO': 11,
        'AC': 12,
        'AM': 13,
        'RR': 14,
        'PA': 15,
        'AP': 16,
        'TO': 17,
        'MA': 21,
        'PI': 22,
        'CE': 23,
        'RN': 24,
        'PB': 25,
        'PE': 26,
        'AL': 27,
        'SE': 28,
        'BA': 29,
        'MG': 31,
        'ES': 32,
        'RJ': 33,
        'SP': 35,
        'PR': 41,
        'SC': 42,
        'RS': 43,
        'MS': 50,
        'MT': 51,
        'GO': 52,
        'DF': 53
    }

    def parse_date(self, date: datetime.datetime):
        """
        Parser to return a 04 digits code to compound an NFC-e code.
        """
        year_date = str(date.year)[-2:]
        month_date = str(date.month)
        if len(month_date) == 1:
            month_date = "0" + month_date
        code_date = f"{year_date}{month_date}"
        return code_date

    def validate_dtype(self, variable, type, error_msg):
        if not isinstance(variable, type):
            raise TypeError(f"{error_msg}")

    def nfce(self, **kwargs) -> str:
        """
        Keyword Args:
            invoice_no (str): invoice number with 44 digits or its masked version with 59 character length
            start_dt (datetime.datetime): if no invoice_no has been entered, a start datetime is needed to
            compute a random 04 digits code which has format YYMM. In case of missing value, an random date
            of the current year will be used.
            end_dt (datetime.datetime) : if no invoice_no has been entered, an end datetime is needed to
            compute a random 04 digits code which has format YYMM. In case of missing value, an random date
            of the current year will be used.
        """
        invoice_no = kwargs.get('invoice_no')
        if invoice_no:
            if not isinstance(invoice_cod, str):
                raise TypeError("Convert invoice code to string type")
            else:
                validate_invoice = invoice_cod.isdigit()
                if validate_invoice:
                    assert len(invoice_cod) == 44, "Invalid length of invoice code."
                else:
                    pattern = r'[0-9]{2}-[0-9]{4}-[0-9]{2}\.[0-9]{3}\.[0-9]{3}\/[0-9]{4}-[0-9]{2}-[0-9]{2}-[0-9]{3}-[0-9]{3}.[0-9]{3}\.[0-9]{3}'\
                              r'-[0-9]{3}.[0-9]{3}\.[0-9]{3}-[0-9]{1}'
                    regex = re.compile(pattern)
                    check_pattern = regex.match(invoice_cod)
                    if check_pattern:
                        pass
                    else:
                        raise ValueError("The invoice code does not match the validation.")
        else:
            start_dt = kwargs.get('start_dt')
            end_dt = kwargs.get('end_dt')
            if start_dt and end_dt:
                [self.validate_dtype(variable, datetime.datetime, "The date must be a datetime.datetime object.") for variable in [start_dt, end_dt]]
                picked_date = self.fake.date_between_dates(date_start=start_dt, date_end=end_dt)
                dt_code = self.parse_date(picked_date)  # 2 digits code (YYMM)
            else:
                picked_date = self.fake.date_time_this_year()
                dt_code = self.parse_date(picked_date)  # 2 digits code (YYMM)
            # federation unit code
            get_uf_cod = random.choice([cod for cod in self.uf_cod.values()])
            # CNPJ
            cnpj = str(self.fake.cnpj()).replace(".", "").replace("/", "").replace("-", "")
            nfce_cod = f"{get_uf_cod}{dt_code}{cnpj}"
            last_digits = "".join([random.choice(string.digits) for n in range(24)])
            cod_digits = nfce_cod + last_digits
            nfce_cod = f"{cod_digits[:2]}-{cod_digits[2:6]}-{cod_digits[6:8]}.{cod_digits[8:11]}.{cod_digits[11:14]}/{cod_digits[14:18]}-{cod_digits[18:20]}"\
                f"-{cod_digits[20:22]}-{cod_digits[22:25]}-{cod_digits[25:28]}.{cod_digits[28:31]}.{cod_digits[31:34]}-{cod_digits[34:37]}.{cod_digits[37:40]}."\
                f"{cod_digits[40:43]}-{cod_digits[43]}"
            return nfce_cod


data = Factory.create()
data.add_provider(InvoiceNumber)
print(data.nfce())
for i in range(5):
    print(data.nfce(**{'start_dt': datetime.datetime(2005, 1, 1), 'end_dt': datetime.datetime(2019, 1, 31)}))

# this code wil crash
print(data.nfce(**{'start_dt': "2005-1-1", 'end_dt': datetime.datetime(2019, 1, 31)}))
